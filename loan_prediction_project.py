# -*- coding: utf-8 -*-
"""Loan Prediction Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17Ph5ZPpTBUuF8yEVjwxN8GH-UvMTThaV

# **Introduction: Predicting Loan Approval with Synthetic Loan Data**

In lending, effective credit evaluation is essential for minimizing defaults and optimizing decision-making. This project focuses on predicting loan approval outcomes and estimating risk scores using synthetic financial data, enabling deeper insights into applicant creditworthiness and enhancing lending practices

**Importing the dependencies**
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.preprocessing import StandardScaler, LabelEncoder
from imblearn.over_sampling import SMOTE
from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor
from sklearn.metrics import classification_report, mean_squared_error, r2_score
from sklearn.metrics import accuracy_score

"""**Data Collection**

---


"""

# Loading the dataset to Pandas Dataframe
Loan_Data = pd.read_csv('/content/drive/MyDrive/train_u6lujuX_CVtuZ9i (1).csv')

# Printing the first 5 rows of the dataframe
Loan_Data.head()

# Number of rows and columns
Loan_Data.shape

# Overview of dataframe structure
Loan_Data.info()

# Statistical measures
Loan_Data.describe().T

# Number of missing values in each column
Loan_Data.isnull().sum()

"""# **Data Preprocessing**"""

# Data Cleaning and Preprocessing

# Replace '3+' with '4' in the 'Dependents' column
Loan_Data['Dependents'] = Loan_Data['Dependents'].replace('3+', '4')

# Fill missing values for categorical columns with the mode
def fill_categorical_mode(Loan_Data, columns):
    for col in columns:
        Loan_Data[col].fillna(Loan_Data[col].mode()[0], inplace=True)

categorical_columns = ['Gender', 'Married', 'Dependents', 'Self_Employed', 'Credit_History']
fill_categorical_mode(Loan_Data, categorical_columns)

# Fill missing values for numerical columns with the median
def fill_numerical_median(Loan_Data, columns):
    for col in columns:
        Loan_Data[col].fillna(Loan_Data[col].median(), inplace=True)

numerical_columns = ['LoanAmount', 'Loan_Amount_Term']
fill_numerical_median(Loan_Data, numerical_columns)

# Verify missing values are handled
print("Missing Values After Cleaning:")
print(Loan_Data.isnull().sum())

# Encoding categorical variables and scaling numerical features

# Encode categorical variables using LabelEncoder
label_encoders = {}
categorical_columns = ['Gender', 'Married', 'Dependents', 'Education', 'Self_Employed', 'Property_Area', 'Loan_Status']

for col in categorical_columns:
    le = LabelEncoder()
    Loan_Data[col] = le.fit_transform(Loan_Data[col])
    label_encoders[col] = le

# Scale numerical features using StandardScaler
scaler = StandardScaler()
numerical_columns = ['ApplicantIncome', 'CoapplicantIncome', 'LoanAmount', 'Loan_Amount_Term']
Loan_Data[numerical_columns] = scaler.fit_transform(Loan_Data[numerical_columns])

# Display the first few rows of the processed dataset
print("Processed Dataset:")
print(Loan_Data.head())

"""# **Exploratory Data Analysis**"""

# Group by Gender and sum Loan_Status
Loan_status_by_gender = Loan_Data.groupby('Gender', as_index=False)['Loan_Status'].sum()

# Rename the 'Loan_Status' column to something more descriptive
Loan_status_by_gender = Loan_status_by_gender.rename(columns={'Loan_Status': 'Approved_Loans'})

# Display the result
print(Loan_status_by_gender)

sns.barplot(data = Loan_status_by_gender, x = 'Gender', y = 'Approved_Loans', palette='Set2')
plt.title('Loan_status_by_gender')
plt.show()

# Distribution of Applicant Income
plt.figure(figsize=(8, 5))
sns.histplot(Loan_Data['ApplicantIncome'], kde=True)
plt.title('Distribution of Applicant Income')
plt.xlabel('Applicant Income')
plt.ylabel('Frequency')
plt.show()

# Distribution of Loan Amount
plt.figure(figsize=(8, 5))
sns.histplot(Loan_Data['LoanAmount'], kde=True)
plt.title('Distribution of Loan Amount')
plt.xlabel('Loan Amount')
plt.ylabel('Frequency')
plt.show()

# Analyze the distribution of target variables
plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
sns.countplot(data=Loan_Data, x='Loan_Status', palette='Set1')
plt.title('Distribution of Loan Approval')

# Calculate approval rate
approval_rate = (Loan_Data['Loan_Status'].mean() * 100)
print("\nLoan Approval Rate: {:.2f}%".format(approval_rate))

# Box Plots (for categorical vs. numerical)
plt.figure(figsize=(10, 6))
sns.boxplot(data=Loan_Data, x='Loan_Status', y='ApplicantIncome', palette='Set2')
plt.title('Applicant Income vs Loan Status')
plt.show()

# Scatter Plot (for numerical vs. numerical)
plt.figure(figsize=(8, 6))
sns.scatterplot(data=Loan_Data, x='ApplicantIncome', y='LoanAmount', hue='Loan_Status')
plt.title('Applicant Income vs Loan Amount')
plt.show()

# Grouped Bar Charts (for categorical vs. categorical)
Loan_status_by_gender_marital = Loan_Data.groupby(['Gender', 'Married'], as_index=False)['Loan_Status'].sum()
Loan_status_by_gender_marital['Gender'] = Loan_status_by_gender_marital['Gender'].map({0: 'Male', 1: 'Female'})
Loan_status_by_gender_marital['Married'] = Loan_status_by_gender_marital['Married'].map({0: 'No', 1: 'Yes'})
sns.barplot(data=Loan_status_by_gender_marital, x='Gender', y='Loan_Status', hue='Married', palette='Set2')
plt.title('Loan Status by Gender and Marital Status')
plt.show()

plt.figure(figsize=(10, 6))
sns.boxplot(data=Loan_Data, x='Loan_Status', y='LoanAmount', palette='Set1')
plt.title('Loan Amount vs Loan Status')
plt.show()

# Calculate correlation matrix
correlation_matrix = Loan_Data.drop('Loan_ID', axis=1).corr()
plt.figure(figsize=(12, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', center=0)
plt.title('Correlation Matrix')
plt.show()

# Print key statistics for important features
print("\nKey Features Statistics for Approved vs Rejected Loans:")
for feature in ['ApplicantIncome', 'LoanAmount', 'Loan_Amount_Term', 'Credit_History']:
    print(f"\n{feature} Statistics by Loan Status:")
    print(Loan_Data.groupby('Loan_Status')[feature].describe())

"""# **Model Building**"""

# Prepare features for modeling

X = Loan_Data.drop(['Loan_ID', 'Loan_Status'], axis=1)
y_loan = Loan_Data['Loan_Status']

# Split the data
X_train, X_test, y_train, y_test = train_test_split(X, y_loan, test_size=0.1, random_state=2)

# Train Random Forest Classifier for Loan Approval
rf_classifier = RandomForestClassifier(n_estimators=100, random_state=42)
rf_classifier.fit(X_train, y_train)

# Train SVM Classifier
svm_classifier = SVC(random_state=42)
svm_classifier.fit(X_train, y_train)

# Make predictions
rf_predictions = rf_classifier.predict(X_test)
svm_predictions = svm_classifier.predict(X_test)

# Evaluate Random Forest
print("Random Forest Evaluation:")
print("Accuracy:", accuracy_score(y_test, rf_predictions))
print(classification_report(y_test, rf_predictions))

# Evaluate SVM
print("\nSVM Evaluation:")
print("Accuracy:", accuracy_score(y_test, svm_predictions))
print(classification_report(y_test, svm_predictions))

# Compare Model Performance
rf_accuracy = accuracy_score(y_test, rf_predictions)
svm_accuracy = accuracy_score(y_test, svm_predictions)

if rf_accuracy > svm_accuracy:
    print("\nRandom Forest performs better with an accuracy of {:.2f}%".format(rf_accuracy * 100))
else:
    print("\nSVM performs better with an accuracy of {:.2f}%".format(svm_accuracy * 100))

"""# **Building a Predictive System**"""

Input_data = (1,0,0,0,0,0.072991,-0.554487,-0.211241,0.273231, 1.0,2)

#change the input data to a numpy array
input_data_as_numpy_array = np.asarray(Input_data)

#reshape the numpy array as we are predicting for only on instance
input_data_reshaped = input_data_as_numpy_array.reshape(1,-1)

loan_prediction = svm_classifier.predict(input_data_reshaped)

print("Loan Prediction:", loan_prediction[0])  # Print loan prediction (0 or 1)

if (loan_prediction[0] == 0):
  print('The loan is not approved')
else:
  print('The loan is approved')

